#include <map>
#include <vector>
#include <string>
#include <getopt.h>
#include <stdlib.h>
#include <iostream>
#include "Variant.h"
#include "api/BamReader.h"
#include "split.h"

using namespace BamTools;
using namespace vcf;
using namespace std;

void printUsage(int argc, char** argv) {

    cerr << "usage: " << argv[0] << " -b BAMFILE -v VCFFILE" << endl
         << endl
         << "options:" << endl
         << "    -h, --help         this dialog" << endl
         << "    -b, --bam FILE     use this BAM as input" << endl
         << "    -v, --vcf FILE     use this VCF as input" << endl
         << "    -t, --tag TAG      tag VCF records with unique primers in the BAM" << endl
         << endl
         << "Checks if BAM alignments of \"primers\" generated by vcfprimers" << endl
         << "(from vcflib) uniquely align.  VCF records with 2 unique primers are" << endl
         << "tagged with TAG." << endl
         << endl
         << "author: Erik Garrison <erik.garrison@bc.edu>" << endl;

}

void getPrimerNameParts(BamAlignment& al, string& chrom, int& pos, string& flank) {

    vector<string> parts = split(al.Name, "_");
    if (parts.size() != 3) {
        cerr << "could not parse the name for " << al.Name << ", was this alignment generated using vcfprimers?" << endl;
        exit(1);
    }

    chrom = parts.at(0);
    pos = atoi(parts.at(1).c_str());
    flank = parts.at(2);

}


int main(int argc, char** argv) {

    string bamfile;
    string tag;
    string vcffile;

    if (argc == 1) {
        printUsage(argc, argv);
        return 1;
    }

    // parse command-line options
    int c;

    while (true) {

        static struct option long_options[] =
        {
            {"help", no_argument, 0, 'h'},
            {"bam",  required_argument, 0, 'b'},
            {"vcf",  required_argument, 0, 'v'},
            {"tag", required_argument, 0, 't'},
            {0, 0, 0, 0}
        };
        /* getopt_long stores the option index here. */
        int option_index = 0;

        c = getopt_long (argc, argv, "hb:v:t:",
                         long_options, &option_index);

        if (c == -1)
            break;
 
        switch (c) {

            case '?':
                printUsage(argc, argv);
                return 0;
                break;

            case 'h':
                printUsage(argc, argv);
                return 0;
                break;

            case 'v':
                vcffile = optarg;
                break;

            case 't':
                tag = optarg;
                break;

            case 'b':
                bamfile = optarg;
                break;

            default:
                return 1;
                break;
        }
    }

    if (vcffile.empty()) {
        cerr << "please supply a VCF file" << endl;
        return 1;
    }

    if (bamfile.empty()) {
        cerr << "please supply a BAM file" << endl;
        return 1;
    }

    if (tag.empty()) {
        cerr << "please specify a tag to apply to records which have uniquely mapped primers" << endl;
        return 1;
    }

    BamReader reader;
    if (!reader.Open(bamfile)) {
        cerr << "could not open input BAM files" << endl;
        return 1;
    }

    VariantCallFile variantFile;
    variantFile.open(vcffile);

    if (!variantFile.is_open()) {
        cerr << "could not open " << vcffile << endl;
        return 1;
    }

    variantFile.addHeaderLine("##INFO=<ID="+tag+",Number=1,Type=Flag,Description=\"Uniquely mapped primers\">");
    cout << variantFile.header << endl;

    Variant var(variantFile);
    variantFile.getNextVariant(var);

    BamAlignment al;
    vector<pair<string, int> > primers;

    while (reader.GetNextAlignment(al)) {

        if (!al.IsMapped()) {
            continue;
        }

        // get the chrom, position, and flank side
        vector<string> parts = split(al.Name, "_");
        if (parts.size() != 3) {
            cerr << "could not parse the name for " << al.Name << ", was this alignment generated using vcfprimers?" << endl;
            return 1;
        }

        string chrom; int pos; string flank;
        getPrimerNameParts(al, chrom, pos, flank);

        if (pos < var.position) {
            continue;
        }

        if (flank == "LEFT") {
            if (!primers.empty()) {
                primers.clear();
            }
            primers.push_back(make_pair(chrom, pos));
        } else if (flank == "RIGHT") {
            if (primers.empty()) {
                continue;
            } else {
                primers.push_back(make_pair(chrom, pos));
            }
        }

        if (primers.size() == 2) {
            pair<string, int>& left = primers.at(0);
            pair<string, int>& right = primers.at(1);
            if (left.first == right.first && left.second == right.second) {
                // we have the primer!  now find the VCF record for it
                do {
                    if (var.sequenceName == left.first && var.position == left.second) {
                        var.infoFlags[tag] = true; // set the tag
                        break;  // and break out of the loop
                    }
                    cout << var << endl;
                } while (variantFile.getNextVariant(var));
            }
        }
    }

    reader.Close();

    return 0;

}
